{"meta":{"title":"Warcello博客","subtitle":null,"description":null,"author":"Warcello","url":"http://blog.warcello.cn"},"pages":[{"title":"About","date":"2017-08-15T00:48:31.000Z","updated":"2017-08-15T00:48:31.000Z","comments":false,"path":"about/index.html","permalink":"http://blog.warcello.cn/about/index.html","excerpt":"","text":"个人简介"},{"title":"Categories","date":"2017-08-15T00:49:39.000Z","updated":"2017-08-15T00:49:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.warcello.cn/categories/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-08-15T00:51:33.000Z","updated":"2017-08-15T00:51:33.000Z","comments":true,"path":"links/index.html","permalink":"http://blog.warcello.cn/links/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-08-15T00:50:58.000Z","updated":"2017-08-15T00:50:58.000Z","comments":false,"path":"repository/index.html","permalink":"http://blog.warcello.cn/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-15T00:51:07.000Z","updated":"2017-08-15T00:51:07.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.warcello.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"12.Webpack img-loader","slug":"webpackimage","date":"2017-08-07T01:13:28.000Z","updated":"2017-08-15T01:14:14.000Z","comments":true,"path":"2017/08/07/webpackimage/","link":"","permalink":"http://blog.warcello.cn/2017/08/07/webpackimage/","excerpt":"","text":"图片压缩 安装1$ npm install img-loader --save-dev 使用1234567891011module: &#123; rules: [ &#123; test: /\\.(jpe?g|png|gif|svg)$/i, use: [ &apos;url-loader?limit=10000&apos;, &apos;img-loader&apos; ] &#125; ]&#125;","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"11.Webpack Manifests","slug":"Manifests","date":"2017-08-06T01:10:22.000Z","updated":"2017-08-15T01:12:55.000Z","comments":true,"path":"2017/08/06/Manifests/","link":"","permalink":"http://blog.warcello.cn/2017/08/06/Manifests/","excerpt":"","text":"我们可以成功地将（我们）捆绑的版块（hash）版本（哈希），但现在我们有一个新问题：如果文件哈希不断变化，我们如何在HTML中引用它？我们不能再硬编码路径了。而是让webpack生成一个manifest.json文件。这样，使用Ruby，PHP或者填空，我们可以读取这个文件并动态地确定并获取正确的哈希。 12345678function () &#123; this.plugin('done',stats =&gt; &#123; require('fs').writeFileSync( path.join(__dirname,'dist/manifest.json'), JSON.stringify(stats.toJson().assetsByChunkName) ) &#125;) &#125;","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"10.clean-webpack-plugin","slug":"cleanplugin","date":"2017-08-04T01:11:23.000Z","updated":"2017-08-15T01:13:05.000Z","comments":true,"path":"2017/08/04/cleanplugin/","link":"","permalink":"http://blog.warcello.cn/2017/08/04/cleanplugin/","excerpt":"","text":"一个webpack插件，在构建之前删除你的构建文件夹 安装1npm i clean-webpack-plugin --save-dev 使用1234567891011121314151617181920212223242526272829303132333435363738394041const CleanWebpackPlugin = require('clean-webpack-plugin'); //使用const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npmconst webpack = require('webpack'); //to access built-in pluginsconst path = require('path');//使用let pathsToClean = [ 'dist', 'build']//使用let cleanOptions = &#123; root: '/full/webpack/root/path', exclude: ['shared.js'], verbose: true, dry: false&#125;// sample WebPack configconst webpackConfig = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, loader: 'babel-loader' &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(pathsToClean, cleanOptions),//使用 new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;Paths","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"9.Webpack Plugs PurifyCSS","slug":"PurifyCSS","date":"2017-08-03T01:10:09.000Z","updated":"2017-08-15T01:11:00.000Z","comments":true,"path":"2017/08/03/PurifyCSS/","link":"","permalink":"http://blog.warcello.cn/2017/08/03/PurifyCSS/","excerpt":"","text":"此插件使用PurifyCSS从CSS中删除未使用的选择器,应该配合extract-text-webpack-plugin使用 没有任何CSS文件作为资产发布，这个插件什么都不做。您还可以使用文件插件将CSS文件放入输出文件夹，但强烈建议您使用Extract Text插件的PurifyCSS插件。 安装1npm i -D purifycss-webpack purify-css 使用1234567891011121314151617181920212223242526272829const path = require('path');const glob = require('glob');const ExtractTextPlugin = require('extract-text-webpack-plugin');const PurifyCSSPlugin = require('purifycss-webpack');module.exports = &#123; entry: &#123;...&#125;, output: &#123;...&#125;, module: &#123; rules: [ &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#123; fallbackLoader: 'style-loader', loader: 'css-loader' &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin('[name].[contenthash].css'), // Make sure this is after ExtractTextPlugin! new PurifyCSSPlugin(&#123; // Give paths to parse for rules. These should be absolute! paths: glob.sync(path.join(__dirname, 'app/*.html')), minimize:true,//代码压缩 &#125;) ]&#125;;","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"8.Webpack Loader之css-loader,row-loader,file-loader","slug":"loader","date":"2017-08-02T01:08:49.000Z","updated":"2017-08-15T01:10:42.000Z","comments":true,"path":"2017/08/02/loader/","link":"","permalink":"http://blog.warcello.cn/2017/08/02/loader/","excerpt":"","text":"今天讲讲图片url如何通过webpack编译的 1.css-loader的中禁用url处理 12345678910111213&#123; test:/\\.s[ac]ss$/, use:ExtractTextPlugin.extract(&#123; use:[ &#123; loader:'css-loader', options:&#123; url:false &#125;, &#125;, ], fallback:'style-loader', &#125;),&#125;, 这样在运行后webpack就不会对url中的内容进行处理 2.row-loader 安装 1npm install --save-dev raw-loader 使用 1234&#123; test: /\\.png|jpg|gif$/, use: &apos;raw-loader&apos;&#125; 这样就会在dist目录下生成一张.png的图片 3.file-load 生成文件 安装 1npm install --save-dev file-loader 使用 12345678&#123; test: /\\.(png|jpg|gif)$/, loader: &apos;file-loader&apos;, options: &#123; name: &apos;images/[name].[hash].[ext]&apos; &#125;&#125;, 这里说一下options里的name就是指生成的文件名，hash指生成带hash的文件名，ext指文件后缀","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"7.Webpack插件ExtractTextWebpackPlugin","slug":"ExtractTextWebpackPlugin","date":"2017-08-01T01:07:45.000Z","updated":"2017-08-15T01:09:38.000Z","comments":true,"path":"2017/08/01/ExtractTextWebpackPlugin/","link":"","permalink":"http://blog.warcello.cn/2017/08/01/ExtractTextWebpackPlugin/","excerpt":"","text":"它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。 1.安装12# 对于 webpack 3npm install --save-dev extract-text-webpack-plugin 2.用法12345678910111213141516171819//webpack.config.js头部引入var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(\"styles.css\"), ]&#125; 3.修改文件名filename 参数可以是 Function。它通过 getPath 来处理格式，如 css/[name].css，并返回真实的文件名，你可以用 css 替换 css/js，你会得到新的路径 css/a.css。 12345678910111213141516171819202122232425262728entry: &#123; app:[ './src/main.js', './src/main.scss', ] &#125;, output: &#123; path: path.resolve(__dirname,'./dist'), filename: '[name].js' &#125;, module:&#123; rules:[ &#123; test:/\\.s[ac]ss$/, use:ExtractTextPlugin.extract(&#123; use:['css-loader','sass-loader'], fallback:'style-loader', &#125;), &#125;, ] &#125;, plugins: [ new ExtractTextPlugin('[name].css'), ] &#125;; 4.LoaderOptionsPluginloader-options-plugin 和其他插件不同，它用于将 webpack 1 迁移至 webpack 2。在 webpack 2 中，对 webpack.config.js 的结构要求变得更加严格；不再开放扩展给其他的 loader/插件。webpack 2 推荐的使用方式是直接传递 options 给 loader/插件（换句话说，配置选项将不是全局/共享的）。 不过，在某个 loader 升级为依靠直接传递给它的配置选项运行之前，可以使用 loader-options-plugin 来抹平差异。你可以通过这个插件配置全局/共享的 loader 配置，使所有的 loader 都能收到这些配置。 简单说就是格式转化转换成webpack能适配的代码格式（目前只是自己的理解） 用法直接在plugins数组中加入 123new webpack.LoaderOptionsPlugin(&#123; minimize: true, &#125;) 5.本节webpack.config.js源代码如下123456789101112131415161718192021222324252627282930313233343536373839404142var webpack = require('webpack');var path = require('path');var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");var inProduction = (process.env.NODE_ENV == 'production');module.exports = &#123; entry: &#123; app:[ './src/main.js', './src/main.scss' ] &#125;, output: &#123; path: path.resolve(__dirname,'./dist'), filename: '[name].js' &#125;, module:&#123; rules:[ &#123; test:/\\.s[ac]ss$/, use:ExtractTextPlugin.extract(&#123; use:['css-loader','sass-loader'], fallback:'style-loader', &#125;), &#125;, ] &#125;, plugins: [ new ExtractTextPlugin('[name].css'), new webpack.LoaderOptionsPlugin(&#123; minimize: inProduction, &#125;) ] &#125;;if (inProduction) &#123; module.exports.plugins.push( new webpack.optimize.UglifyJsPlugin() );&#125; 6.最后12npm run dev //代码未压缩npm run production //代码已压缩","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"6.Webpack插件之sass-loader","slug":"webpacksassloader","date":"2017-07-29T01:05:14.000Z","updated":"2017-08-15T01:05:58.000Z","comments":true,"path":"2017/07/29/webpacksassloader/","link":"","permalink":"http://blog.warcello.cn/2017/07/29/webpacksassloader/","excerpt":"","text":"1.安装 1npm install sass-loader node-sass webpack --save-dev 2.使用在webpack.config.js中加入如下代码 1234&#123; test:/\\.s[ac]ss$/, use:['style-loader','css-loader','sass-loader']&#125;, 创建main.scss文件 12345$primary:green;body &#123; background:$primary;&#125; 修改main.js将main.scss引入进去 1require('./main.scss'); 运行npm run dev查看效果 点击查看sass-loader原文文档","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"5.Webpack 插件","slug":"webpackplugs","date":"2017-07-28T01:04:15.000Z","updated":"2017-08-15T01:05:24.000Z","comments":true,"path":"2017/07/28/webpackplugs/","link":"","permalink":"http://blog.warcello.cn/2017/07/28/webpackplugs/","excerpt":"","text":"插件可以完成更多 loader 不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 接下来我们演示一下代码压缩这个插件 1.修改webpack.config.js,添加plugins:12345plugins: [ new webpack.optimize.UglifyJsPlugin() ] 然后运行npm run build查看效果 2.这么运行之后发现代码压缩成一行了，不利于查看，现在我们把这个改一下，让他在开发环境压缩代码，在本地环境不进行压缩修改webpackage.config.js 12345678910111213141516171819202122232425262728var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname,'./dist'), filename: 'bundle.js' &#125;, module:&#123; rules:[ &#123; test:/\\.css$/, use:['style-loader','css-loader'] &#125; ] &#125;, plugins: [ ] &#125;;if (process.env.NODE_ENV == 'production') &#123; module.exports.plugins.push( new webpack.optimize.UglifyJsPlugin() );&#125; 修改package.json 12345\"scripts\": &#123; \"dev\": \"webpack\", \"production\": \"NODE_ENV=production webpack\", \"watch\": \"npm run build --watch\" &#125;, 最后我们可以分别运行npm run dev,npm run production查看生成的js","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"4.Webpack loader带代码转换","slug":"webpackloader","date":"2017-07-27T01:03:00.000Z","updated":"2017-08-15T01:03:53.000Z","comments":true,"path":"2017/07/27/webpackloader/","link":"","permalink":"http://blog.warcello.cn/2017/07/27/webpackloader/","excerpt":"","text":"loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 创建css文件我们在src文件夹下创建一个main.css文件 123body &#123; background:yellow;&#125; 安装loader插件1npm install css-loader style-loader --save-dev 修改webpack.config.js12345678module:&#123; rules:[ &#123; test:/\\.css$/, use:['style-loader','css-loader'] &#125; ]&#125; 运行npm rum build后查看浏览器效果内联可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 1import Styles from 'style-loader!css-loader?modules!./styles.css';","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"3.Webpack 配置文件","slug":"webpackConfig","date":"2017-07-26T01:01:41.000Z","updated":"2017-08-15T01:02:30.000Z","comments":true,"path":"2017/07/26/webpackConfig/","link":"","permalink":"http://blog.warcello.cn/2017/07/26/webpackConfig/","excerpt":"","text":"根据文档描述，webpack在执行的时候，除了在命令行传递参数，还可以通过制定参数执行。默认情况下，会搜索当前目录的webpack.config.js文件。这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件 创建webpack.config.js继续我们的项目，在根目录下创建webpack.config.js文件并加入一下内容 123456789var webpack = require('webpack');module.exports = &#123; entry: './src/main.js', output: &#123; path: __dirname+'/dist', filename: 'bundle.js' &#125;&#125; 打开命令行运行 webpack 并查看效果这里需要注意一下路径问题，output中的path必须是绝对路径不能使用相对路径否则会报错 修改package.js继续修改package.js将scripts换成如下 1234\"scripts\": &#123; \"build\": \"webpack\", \"watch\": \"npm run build --watch\" &#125;, 运行webpack查看效果","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"2.Webpack Hello World","slug":"sayHello","date":"2017-07-25T01:58:13.000Z","updated":"2017-08-15T01:00:38.000Z","comments":true,"path":"2017/07/25/sayHello/","link":"","permalink":"http://blog.warcello.cn/2017/07/25/sayHello/","excerpt":"","text":"创建项目1.初始化项目 123mkdir learn-webpackcd learn-webpacknpm init -y 此时项目底下将有一个package.json文件 2.npm安装webpack 12//此命令是全局安装 npm install webpack -g 此时 Webpack 已经安装到了全局环境下，可以通过命令行 webpack -h 试试。 通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack 1npm install webpack --save-dev 3.创建main.js文件并对改文件进行打包 main.js 1alert(\"hello world\") 12345//全局安装使用这个方法打包webpack src/main.js dist/bundle.js//本地项目打包使用node_modules/.bin/webpack src/main.js dist/bundle.js 4.创建index.html文件并将bundle.js引入 index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello Wold!&lt;/h1&gt;&lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.打开浏览器查看效果 6.修改main的js后发现alert不对重新打包后恢复正常，总不能每次修改都重新编译吧，当然不会，webpack提供我们一个观察者模式。 12345//全局安装使用这个方法打包webpack src/main.js dist/bundle.js --watch//本地项目打包使用node_modules/.bin/webpack src/main.js dist/bundle.js --watch 此时再对文章修改之后就不用再打包了我们在将这些命令优化一下，打开package.js在script数组中修改如下 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;, &quot;watch&quot;: &quot;npm run build --watch&quot; &#125;, 打开命令行工具运行1npm run watch 此效果跟直接运行webpack src/main.js dist/bundle.js --watch一致","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]},{"title":"1.webpack 简介","slug":"Webpackage","date":"2017-07-24T00:55:38.000Z","updated":"2017-08-15T01:00:47.000Z","comments":true,"path":"2017/07/24/Webpackage/","link":"","permalink":"http://blog.warcello.cn/2017/07/24/Webpackage/","excerpt":"","text":"什么是webpack Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源 特点 Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”) 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译","categories":[{"name":"Webpack,前端","slug":"Webpack-前端","permalink":"http://blog.warcello.cn/categories/Webpack-前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.warcello.cn/tags/Webpack/"}]}]}